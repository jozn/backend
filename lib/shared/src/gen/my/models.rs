// DO NOT MODIFY AUTO-GENERATED BY PB-WALKER
use mysql_async::prelude::*;
use mysql_async::{FromRowError, OptsBuilder, Params, Row, Pool};
use mysql_common::row::ColumnIndex;

use mysql_common::value::Value;

//use crate::xc::CWError;

// Every Table Must Have Primary Keys to Be Included In This Output
// Primiay Keys must be one column (no compostion types yet)
// Primiay Keys can be 1) Auto Increment 2) Other self Inserted

// Implemention is simple NOT many features is suported in Rust version:
// Keep mysql data types in int, bigint, text, varchar, bool, blob
// No signed integer is supported
// For now Primary key should only be numbers
// Not fully ORM is supported: limited to CRUD on rows + Indexes querys



#[derive(Debug, PartialEq, Eq, Clone)]
pub struct Tweet  { // tweet
    pub tweet_id: u64,
    pub created_time: u64,
    pub text_body: String,
}

impl FromRow for Tweet {
    fn from_row_opt(row: Row) -> Result<Self, FromRowError>
    where
        Self: Sized,
    {
        Ok(Tweet  {
            tweet_id: row.get(0).unwrap_or_default(),
            created_time: row.get(1).unwrap_or_default(),
            text_body: row.get(2).unwrap_or_default(),
        })
    }
}

impl Tweet {
    pub async fn insert(&self, pool: &Pool) -> Result<Tweet,MyError> {
        let mut conn = pool.get_conn().await?;

        let query = r"INSERT INTO twitter.tweet (created_time, text_body) VALUES (?, ?)";
        let p = Params::Positional(vec![self.created_time.clone().into(), self.text_body.clone().into()]);

        let qr = conn.exec_iter(
            query, p
        ).await?;

        let mut cp = self.clone();
        cp.tweet_id = qr.last_insert_id().unwrap() as u64;

       Ok(cp)
    }

    pub async fn update(&self, pool: &Pool) -> Result<(),MyError> {
        let mut conn = pool.get_conn().await?;
        let query = r"UPDATE twitter.tweet SET created_time = ?, text_body = ? WHERE tweet_id = ? ";
        let p = Params::Positional(vec![self.created_time.clone().into(), self.text_body.clone().into(),  self.tweet_id.clone().into() ]);

        let qr = conn.exec_iter(
            query, p
        ).await?;

        Ok(())
    }

    pub async fn delete(&self, pool: &Pool) -> Result<(),MyError> {
        let mut conn = pool.get_conn().await?;

        let query = r"DELETE FROM twitter.tweet WHERE tweet_id = ? ";
        let p = Params::Positional(vec![self.tweet_id.clone().into()]);

        conn.exec_drop(
            query, p
        ).await?;

        Ok(())
    }
}


#[derive(Default, Debug)]
pub struct TweetSelector {
    wheres: Vec<WhereClause>,
    select_cols: Vec<&'static str>,
    order_by:  Vec<&'static str>,
    limit: u32,
    offset: u32,
}

impl TweetSelector {
    pub fn new() -> Self {
        TweetSelector::default()
    }

    pub fn limit(&mut self, size: u32) -> &mut Self {
        self.limit = size;
        self
    }

    pub fn offset(&mut self, size: u32) -> &mut Self {
        self.offset = size;
        self
    }

    pub fn select_all(&mut self) -> &mut Self {
        // Default is select *
        self
    }

    //each column select
    pub fn select_tweet_id(&mut self) -> &mut Self {
        self.select_cols.push("tweet_id");
        self
    }
    
    pub fn select_created_time(&mut self) -> &mut Self {
        self.select_cols.push("created_time");
        self
    }
    
    pub fn select_text_body(&mut self) -> &mut Self {
        self.select_cols.push("text_body");
        self
    }
    

    fn _to_cql(&self) ->  (String, Vec<Value>)  {
        let cql_select = if self.select_cols.is_empty() {
            "*".to_string()
        } else {
            self.select_cols.join(", ")
        };

        let mut cql_query = format!("SELECT {} FROM twitter.tweet", cql_select);

        let (cql_where, where_values) = _get_where(self.wheres.clone());

        if where_values.len() > 0 {
            cql_query.push_str(&format!(" WHERE {}",&cql_where));
        }

        if self.order_by.len() > 0 {
            let cql_orders = self.order_by.join(", ");
            cql_query.push_str( &format!(" ORDER BY {}", &cql_orders));
        };

        if self.limit != 0  {
            cql_query.push_str(&format!(" LIMIT {} ", self.limit));
        };

        if self.offset != 0  {
            cql_query.push_str(&format!(" OFFSET {} ", self.offset));
        };

        (cql_query, where_values)
    }

    pub async fn _get_rows_with_size(&mut self, session: &Pool, size: i64) -> Result<Vec<Tweet>, MyError>   {
        let mut conn = session.get_conn().await?;
        let(cql_query, query_values) = self._to_cql();

        println!("{} - {:?}", &cql_query, &query_values);

        let p = Params::Positional(query_values);

        let query_result = conn
            .exec_map(
                cql_query,p,
                |obj: Tweet| obj
            ).await?;

        Ok(query_result)
    }

    pub async fn get_rows(&mut self, session: &Pool) -> Result<Vec<Tweet>, MyError>{
        self._get_rows_with_size(session,-1).await
    }

    pub async fn get_row(&mut self, session: &Pool) -> Result<Tweet, MyError>{
        let rows = self._get_rows_with_size(session,1).await?;

        let opt = rows.get(0);
        match opt {
            Some(row) => Ok(row.to_owned()),
            None => Err(MyError::NotFound)
        }
    }

    // Modifiers

    
    pub fn order_by_tweet_id_asc(&mut self) -> &mut Self {
		self.order_by.push("tweet_id ASC");
        self
    }

	pub fn order_by_tweet_id_desc(&mut self) -> &mut Self {
		self.order_by.push("tweet_id DESC");
        self
    }

    pub fn order_by_created_time_asc(&mut self) -> &mut Self {
		self.order_by.push("created_time ASC");
        self
    }

	pub fn order_by_created_time_desc(&mut self) -> &mut Self {
		self.order_by.push("created_time DESC");
        self
    }

    pub fn order_by_text_body_asc(&mut self) -> &mut Self {
		self.order_by.push("text_body ASC");
        self
    }

	pub fn order_by_text_body_desc(&mut self) -> &mut Self {
		self.order_by.push("text_body DESC");
        self
    }


    
    pub fn tweet_id_eq (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: " tweet_id = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn tweet_id_lt (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: " tweet_id < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn tweet_id_le (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: " tweet_id <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn tweet_id_gt (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: " tweet_id > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn tweet_id_ge (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: " tweet_id >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_tweet_id_eq (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND tweet_id = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_tweet_id_lt (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND tweet_id < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_tweet_id_le (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND tweet_id <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_tweet_id_gt (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND tweet_id > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_tweet_id_ge (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND tweet_id >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_tweet_id_eq (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR tweet_id = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_tweet_id_lt (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR tweet_id < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_tweet_id_le (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR tweet_id <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_tweet_id_gt (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR tweet_id > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_tweet_id_ge (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR tweet_id >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn created_time_eq (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: " created_time = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn created_time_lt (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: " created_time < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn created_time_le (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: " created_time <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn created_time_gt (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: " created_time > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn created_time_ge (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: " created_time >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_created_time_eq (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND created_time = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_created_time_lt (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND created_time < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_created_time_le (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND created_time <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_created_time_gt (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND created_time > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_created_time_ge (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND created_time >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_created_time_eq (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR created_time = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_created_time_lt (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR created_time < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_created_time_le (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR created_time <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_created_time_gt (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR created_time > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_created_time_ge (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR created_time >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn text_body_eq (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: " text_body = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn text_body_lt (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: " text_body < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn text_body_le (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: " text_body <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn text_body_gt (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: " text_body > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn text_body_ge (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: " text_body >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_text_body_eq (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: "AND text_body = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_text_body_lt (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: "AND text_body < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_text_body_le (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: "AND text_body <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_text_body_gt (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: "AND text_body > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_text_body_ge (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: "AND text_body >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_text_body_eq (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: "OR text_body = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_text_body_lt (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: "OR text_body < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_text_body_le (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: "OR text_body <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_text_body_gt (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: "OR text_body > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_text_body_ge (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: "OR text_body >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }


    //{* .GetRustWhereInsTmplOut *}

}


#[derive(Debug, PartialEq, Eq, Clone)]
pub struct TgChannel  { // tg_channel
    pub channel_id: u32,
    pub username: String,
    pub data: Vec<u8>,
}

impl FromRow for TgChannel {
    fn from_row_opt(row: Row) -> Result<Self, FromRowError>
    where
        Self: Sized,
    {
        Ok(TgChannel  {
            channel_id: row.get(0).unwrap_or_default(),
            username: row.get(1).unwrap_or_default(),
            data: row.get(2).unwrap_or_default(),
        })
    }
}

impl TgChannel {
    pub async fn insert(&self, pool: &Pool) -> Result<TgChannel,MyError> {
        let mut conn = pool.get_conn().await?;

        let query = r"INSERT INTO flip_tg.tg_channel (channel_id, username, data) VALUES (?, ?, ?)";
        let p = Params::Positional(vec![self.channel_id.clone().into(), self.username.clone().into(), self.data.clone().into()]);

        conn.exec_iter(
            query, p
        ).await?;

        let cp = self.clone();

       Ok(cp)
    }

    pub async fn update(&self, pool: &Pool) -> Result<(),MyError> {
        let mut conn = pool.get_conn().await?;
        let query = r"UPDATE flip_tg.tg_channel SET username = ?, data = ? WHERE channel_id = ? ";
        let p = Params::Positional(vec![self.username.clone().into(), self.data.clone().into(),  self.channel_id.clone().into() ]);

        let qr = conn.exec_iter(
            query, p
        ).await?;

        Ok(())
    }

    pub async fn delete(&self, pool: &Pool) -> Result<(),MyError> {
        let mut conn = pool.get_conn().await?;

        let query = r"DELETE FROM flip_tg.tg_channel WHERE channel_id = ? ";
        let p = Params::Positional(vec![self.channel_id.clone().into()]);

        conn.exec_drop(
            query, p
        ).await?;

        Ok(())
    }
}


#[derive(Default, Debug)]
pub struct TgChannelSelector {
    wheres: Vec<WhereClause>,
    select_cols: Vec<&'static str>,
    order_by:  Vec<&'static str>,
    limit: u32,
    offset: u32,
}

impl TgChannelSelector {
    pub fn new() -> Self {
        TgChannelSelector::default()
    }

    pub fn limit(&mut self, size: u32) -> &mut Self {
        self.limit = size;
        self
    }

    pub fn offset(&mut self, size: u32) -> &mut Self {
        self.offset = size;
        self
    }

    pub fn select_all(&mut self) -> &mut Self {
        // Default is select *
        self
    }

    //each column select
    pub fn select_channel_id(&mut self) -> &mut Self {
        self.select_cols.push("channel_id");
        self
    }
    
    pub fn select_username(&mut self) -> &mut Self {
        self.select_cols.push("username");
        self
    }
    
    pub fn select_data(&mut self) -> &mut Self {
        self.select_cols.push("data");
        self
    }
    

    fn _to_cql(&self) ->  (String, Vec<Value>)  {
        let cql_select = if self.select_cols.is_empty() {
            "*".to_string()
        } else {
            self.select_cols.join(", ")
        };

        let mut cql_query = format!("SELECT {} FROM flip_tg.tg_channel", cql_select);

        let (cql_where, where_values) = _get_where(self.wheres.clone());

        if where_values.len() > 0 {
            cql_query.push_str(&format!(" WHERE {}",&cql_where));
        }

        if self.order_by.len() > 0 {
            let cql_orders = self.order_by.join(", ");
            cql_query.push_str( &format!(" ORDER BY {}", &cql_orders));
        };

        if self.limit != 0  {
            cql_query.push_str(&format!(" LIMIT {} ", self.limit));
        };

        if self.offset != 0  {
            cql_query.push_str(&format!(" OFFSET {} ", self.offset));
        };

        (cql_query, where_values)
    }

    pub async fn _get_rows_with_size(&mut self, session: &Pool, size: i64) -> Result<Vec<TgChannel>, MyError>   {
        let mut conn = session.get_conn().await?;
        let(cql_query, query_values) = self._to_cql();

        println!("{} - {:?}", &cql_query, &query_values);

        let p = Params::Positional(query_values);

        let query_result = conn
            .exec_map(
                cql_query,p,
                |obj: TgChannel| obj
            ).await?;

        Ok(query_result)
    }

    pub async fn get_rows(&mut self, session: &Pool) -> Result<Vec<TgChannel>, MyError>{
        self._get_rows_with_size(session,-1).await
    }

    pub async fn get_row(&mut self, session: &Pool) -> Result<TgChannel, MyError>{
        let rows = self._get_rows_with_size(session,1).await?;

        let opt = rows.get(0);
        match opt {
            Some(row) => Ok(row.to_owned()),
            None => Err(MyError::NotFound)
        }
    }

    // Modifiers

    
    pub fn order_by_channel_id_asc(&mut self) -> &mut Self {
		self.order_by.push("channel_id ASC");
        self
    }

	pub fn order_by_channel_id_desc(&mut self) -> &mut Self {
		self.order_by.push("channel_id DESC");
        self
    }

    pub fn order_by_username_asc(&mut self) -> &mut Self {
		self.order_by.push("username ASC");
        self
    }

	pub fn order_by_username_desc(&mut self) -> &mut Self {
		self.order_by.push("username DESC");
        self
    }


    
    pub fn channel_id_eq (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " channel_id = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn channel_id_lt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " channel_id < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn channel_id_le (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " channel_id <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn channel_id_gt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " channel_id > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn channel_id_ge (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " channel_id >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_channel_id_eq (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND channel_id = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_channel_id_lt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND channel_id < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_channel_id_le (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND channel_id <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_channel_id_gt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND channel_id > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_channel_id_ge (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND channel_id >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_channel_id_eq (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR channel_id = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_channel_id_lt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR channel_id < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_channel_id_le (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR channel_id <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_channel_id_gt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR channel_id > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_channel_id_ge (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR channel_id >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn username_eq (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: " username = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn username_lt (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: " username < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn username_le (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: " username <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn username_gt (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: " username > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn username_ge (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: " username >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_username_eq (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: "AND username = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_username_lt (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: "AND username < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_username_le (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: "AND username <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_username_gt (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: "AND username > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_username_ge (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: "AND username >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_username_eq (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: "OR username = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_username_lt (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: "OR username < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_username_le (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: "OR username <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_username_gt (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: "OR username > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_username_ge (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: "OR username >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }


    //{* .GetRustWhereInsTmplOut *}

}


#[derive(Debug, PartialEq, Eq, Clone)]
pub struct TgChannelMsg  { // tg_channel_msg
    pub channel_id: u32,
    pub message_id: u32,
    pub seq_id: u32,
    pub flip_gid: u64,
    pub deleted: u32,
    pub flip_sync: u32,
    pub sync_time: u32,
    pub data: Vec<u8>,
}

impl FromRow for TgChannelMsg {
    fn from_row_opt(row: Row) -> Result<Self, FromRowError>
    where
        Self: Sized,
    {
        Ok(TgChannelMsg  {
            channel_id: row.get(0).unwrap_or_default(),
            message_id: row.get(1).unwrap_or_default(),
            seq_id: row.get(2).unwrap_or_default(),
            flip_gid: row.get(3).unwrap_or_default(),
            deleted: row.get(4).unwrap_or_default(),
            flip_sync: row.get(5).unwrap_or_default(),
            sync_time: row.get(6).unwrap_or_default(),
            data: row.get(7).unwrap_or_default(),
        })
    }
}

impl TgChannelMsg {
    pub async fn insert(&self, pool: &Pool) -> Result<TgChannelMsg,MyError> {
        let mut conn = pool.get_conn().await?;

        let query = r"INSERT INTO flip_tg.tg_channel_msg (channel_id, message_id, seq_id, flip_gid, deleted, flip_sync, sync_time, data) VALUES (?, ?, ?, ?, ?, ?, ?, ?)";
        let p = Params::Positional(vec![self.channel_id.clone().into(), self.message_id.clone().into(), self.seq_id.clone().into(), self.flip_gid.clone().into(), self.deleted.clone().into(), self.flip_sync.clone().into(), self.sync_time.clone().into(), self.data.clone().into()]);

        conn.exec_iter(
            query, p
        ).await?;

        let cp = self.clone();

       Ok(cp)
    }

    pub async fn update(&self, pool: &Pool) -> Result<(),MyError> {
        let mut conn = pool.get_conn().await?;
        let query = r"UPDATE flip_tg.tg_channel_msg SET message_id = ?, seq_id = ?, flip_gid = ?, deleted = ?, flip_sync = ?, sync_time = ?, data = ? WHERE channel_id = ? ";
        let p = Params::Positional(vec![self.message_id.clone().into(), self.seq_id.clone().into(), self.flip_gid.clone().into(), self.deleted.clone().into(), self.flip_sync.clone().into(), self.sync_time.clone().into(), self.data.clone().into(),  self.channel_id.clone().into() ]);

        let qr = conn.exec_iter(
            query, p
        ).await?;

        Ok(())
    }

    pub async fn delete(&self, pool: &Pool) -> Result<(),MyError> {
        let mut conn = pool.get_conn().await?;

        let query = r"DELETE FROM flip_tg.tg_channel_msg WHERE channel_id = ? ";
        let p = Params::Positional(vec![self.channel_id.clone().into()]);

        conn.exec_drop(
            query, p
        ).await?;

        Ok(())
    }
}


#[derive(Default, Debug)]
pub struct TgChannelMsgSelector {
    wheres: Vec<WhereClause>,
    select_cols: Vec<&'static str>,
    order_by:  Vec<&'static str>,
    limit: u32,
    offset: u32,
}

impl TgChannelMsgSelector {
    pub fn new() -> Self {
        TgChannelMsgSelector::default()
    }

    pub fn limit(&mut self, size: u32) -> &mut Self {
        self.limit = size;
        self
    }

    pub fn offset(&mut self, size: u32) -> &mut Self {
        self.offset = size;
        self
    }

    pub fn select_all(&mut self) -> &mut Self {
        // Default is select *
        self
    }

    //each column select
    pub fn select_channel_id(&mut self) -> &mut Self {
        self.select_cols.push("channel_id");
        self
    }
    
    pub fn select_message_id(&mut self) -> &mut Self {
        self.select_cols.push("message_id");
        self
    }
    
    pub fn select_seq_id(&mut self) -> &mut Self {
        self.select_cols.push("seq_id");
        self
    }
    
    pub fn select_flip_gid(&mut self) -> &mut Self {
        self.select_cols.push("flip_gid");
        self
    }
    
    pub fn select_deleted(&mut self) -> &mut Self {
        self.select_cols.push("deleted");
        self
    }
    
    pub fn select_flip_sync(&mut self) -> &mut Self {
        self.select_cols.push("flip_sync");
        self
    }
    
    pub fn select_sync_time(&mut self) -> &mut Self {
        self.select_cols.push("sync_time");
        self
    }
    
    pub fn select_data(&mut self) -> &mut Self {
        self.select_cols.push("data");
        self
    }
    

    fn _to_cql(&self) ->  (String, Vec<Value>)  {
        let cql_select = if self.select_cols.is_empty() {
            "*".to_string()
        } else {
            self.select_cols.join(", ")
        };

        let mut cql_query = format!("SELECT {} FROM flip_tg.tg_channel_msg", cql_select);

        let (cql_where, where_values) = _get_where(self.wheres.clone());

        if where_values.len() > 0 {
            cql_query.push_str(&format!(" WHERE {}",&cql_where));
        }

        if self.order_by.len() > 0 {
            let cql_orders = self.order_by.join(", ");
            cql_query.push_str( &format!(" ORDER BY {}", &cql_orders));
        };

        if self.limit != 0  {
            cql_query.push_str(&format!(" LIMIT {} ", self.limit));
        };

        if self.offset != 0  {
            cql_query.push_str(&format!(" OFFSET {} ", self.offset));
        };

        (cql_query, where_values)
    }

    pub async fn _get_rows_with_size(&mut self, session: &Pool, size: i64) -> Result<Vec<TgChannelMsg>, MyError>   {
        let mut conn = session.get_conn().await?;
        let(cql_query, query_values) = self._to_cql();

        println!("{} - {:?}", &cql_query, &query_values);

        let p = Params::Positional(query_values);

        let query_result = conn
            .exec_map(
                cql_query,p,
                |obj: TgChannelMsg| obj
            ).await?;

        Ok(query_result)
    }

    pub async fn get_rows(&mut self, session: &Pool) -> Result<Vec<TgChannelMsg>, MyError>{
        self._get_rows_with_size(session,-1).await
    }

    pub async fn get_row(&mut self, session: &Pool) -> Result<TgChannelMsg, MyError>{
        let rows = self._get_rows_with_size(session,1).await?;

        let opt = rows.get(0);
        match opt {
            Some(row) => Ok(row.to_owned()),
            None => Err(MyError::NotFound)
        }
    }

    // Modifiers

    
    pub fn order_by_channel_id_asc(&mut self) -> &mut Self {
		self.order_by.push("channel_id ASC");
        self
    }

	pub fn order_by_channel_id_desc(&mut self) -> &mut Self {
		self.order_by.push("channel_id DESC");
        self
    }

    pub fn order_by_message_id_asc(&mut self) -> &mut Self {
		self.order_by.push("message_id ASC");
        self
    }

	pub fn order_by_message_id_desc(&mut self) -> &mut Self {
		self.order_by.push("message_id DESC");
        self
    }

    pub fn order_by_seq_id_asc(&mut self) -> &mut Self {
		self.order_by.push("seq_id ASC");
        self
    }

	pub fn order_by_seq_id_desc(&mut self) -> &mut Self {
		self.order_by.push("seq_id DESC");
        self
    }

    pub fn order_by_flip_gid_asc(&mut self) -> &mut Self {
		self.order_by.push("flip_gid ASC");
        self
    }

	pub fn order_by_flip_gid_desc(&mut self) -> &mut Self {
		self.order_by.push("flip_gid DESC");
        self
    }

    pub fn order_by_deleted_asc(&mut self) -> &mut Self {
		self.order_by.push("deleted ASC");
        self
    }

	pub fn order_by_deleted_desc(&mut self) -> &mut Self {
		self.order_by.push("deleted DESC");
        self
    }

    pub fn order_by_flip_sync_asc(&mut self) -> &mut Self {
		self.order_by.push("flip_sync ASC");
        self
    }

	pub fn order_by_flip_sync_desc(&mut self) -> &mut Self {
		self.order_by.push("flip_sync DESC");
        self
    }

    pub fn order_by_sync_time_asc(&mut self) -> &mut Self {
		self.order_by.push("sync_time ASC");
        self
    }

	pub fn order_by_sync_time_desc(&mut self) -> &mut Self {
		self.order_by.push("sync_time DESC");
        self
    }


    
    pub fn channel_id_eq (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " channel_id = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn channel_id_lt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " channel_id < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn channel_id_le (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " channel_id <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn channel_id_gt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " channel_id > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn channel_id_ge (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " channel_id >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_channel_id_eq (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND channel_id = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_channel_id_lt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND channel_id < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_channel_id_le (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND channel_id <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_channel_id_gt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND channel_id > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_channel_id_ge (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND channel_id >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_channel_id_eq (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR channel_id = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_channel_id_lt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR channel_id < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_channel_id_le (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR channel_id <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_channel_id_gt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR channel_id > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_channel_id_ge (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR channel_id >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn message_id_eq (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " message_id = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn message_id_lt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " message_id < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn message_id_le (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " message_id <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn message_id_gt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " message_id > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn message_id_ge (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " message_id >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_message_id_eq (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND message_id = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_message_id_lt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND message_id < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_message_id_le (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND message_id <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_message_id_gt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND message_id > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_message_id_ge (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND message_id >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_message_id_eq (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR message_id = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_message_id_lt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR message_id < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_message_id_le (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR message_id <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_message_id_gt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR message_id > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_message_id_ge (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR message_id >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn seq_id_eq (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " seq_id = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn seq_id_lt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " seq_id < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn seq_id_le (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " seq_id <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn seq_id_gt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " seq_id > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn seq_id_ge (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " seq_id >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_seq_id_eq (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND seq_id = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_seq_id_lt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND seq_id < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_seq_id_le (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND seq_id <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_seq_id_gt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND seq_id > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_seq_id_ge (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND seq_id >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_seq_id_eq (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR seq_id = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_seq_id_lt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR seq_id < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_seq_id_le (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR seq_id <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_seq_id_gt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR seq_id > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_seq_id_ge (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR seq_id >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn flip_gid_eq (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: " flip_gid = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn flip_gid_lt (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: " flip_gid < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn flip_gid_le (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: " flip_gid <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn flip_gid_gt (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: " flip_gid > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn flip_gid_ge (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: " flip_gid >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_flip_gid_eq (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND flip_gid = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_flip_gid_lt (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND flip_gid < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_flip_gid_le (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND flip_gid <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_flip_gid_gt (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND flip_gid > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_flip_gid_ge (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND flip_gid >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_flip_gid_eq (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR flip_gid = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_flip_gid_lt (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR flip_gid < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_flip_gid_le (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR flip_gid <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_flip_gid_gt (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR flip_gid > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_flip_gid_ge (&mut self, val: u64 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR flip_gid >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn deleted_eq (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " deleted = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn deleted_lt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " deleted < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn deleted_le (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " deleted <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn deleted_gt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " deleted > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn deleted_ge (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " deleted >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_deleted_eq (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND deleted = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_deleted_lt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND deleted < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_deleted_le (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND deleted <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_deleted_gt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND deleted > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_deleted_ge (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND deleted >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_deleted_eq (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR deleted = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_deleted_lt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR deleted < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_deleted_le (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR deleted <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_deleted_gt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR deleted > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_deleted_ge (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR deleted >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn flip_sync_eq (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " flip_sync = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn flip_sync_lt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " flip_sync < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn flip_sync_le (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " flip_sync <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn flip_sync_gt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " flip_sync > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn flip_sync_ge (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " flip_sync >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_flip_sync_eq (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND flip_sync = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_flip_sync_lt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND flip_sync < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_flip_sync_le (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND flip_sync <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_flip_sync_gt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND flip_sync > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_flip_sync_ge (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND flip_sync >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_flip_sync_eq (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR flip_sync = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_flip_sync_lt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR flip_sync < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_flip_sync_le (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR flip_sync <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_flip_sync_gt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR flip_sync > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_flip_sync_ge (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR flip_sync >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn sync_time_eq (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " sync_time = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn sync_time_lt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " sync_time < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn sync_time_le (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " sync_time <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn sync_time_gt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " sync_time > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn sync_time_ge (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " sync_time >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_sync_time_eq (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND sync_time = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_sync_time_lt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND sync_time < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_sync_time_le (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND sync_time <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_sync_time_gt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND sync_time > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_sync_time_ge (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND sync_time >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_sync_time_eq (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR sync_time = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_sync_time_lt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR sync_time < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_sync_time_le (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR sync_time <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_sync_time_gt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR sync_time > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_sync_time_ge (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR sync_time >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }


    //{* .GetRustWhereInsTmplOut *}

}


#[derive(Debug, PartialEq, Eq, Clone)]
pub struct TgLink  { // tg_link
    pub hash: String,
    pub channel_id: u32,
    pub expired: u32,
}

impl FromRow for TgLink {
    fn from_row_opt(row: Row) -> Result<Self, FromRowError>
    where
        Self: Sized,
    {
        Ok(TgLink  {
            hash: row.get(0).unwrap_or_default(),
            channel_id: row.get(1).unwrap_or_default(),
            expired: row.get(2).unwrap_or_default(),
        })
    }
}

impl TgLink {
    pub async fn insert(&self, pool: &Pool) -> Result<TgLink,MyError> {
        let mut conn = pool.get_conn().await?;

        let query = r"INSERT INTO flip_tg.tg_link (hash, channel_id, expired) VALUES (?, ?, ?)";
        let p = Params::Positional(vec![self.hash.clone().into(), self.channel_id.clone().into(), self.expired.clone().into()]);

        conn.exec_iter(
            query, p
        ).await?;

        let cp = self.clone();

       Ok(cp)
    }

    pub async fn update(&self, pool: &Pool) -> Result<(),MyError> {
        let mut conn = pool.get_conn().await?;
        let query = r"UPDATE flip_tg.tg_link SET channel_id = ?, expired = ? WHERE hash = ? ";
        let p = Params::Positional(vec![self.channel_id.clone().into(), self.expired.clone().into(),  self.hash.clone().into() ]);

        let qr = conn.exec_iter(
            query, p
        ).await?;

        Ok(())
    }

    pub async fn delete(&self, pool: &Pool) -> Result<(),MyError> {
        let mut conn = pool.get_conn().await?;

        let query = r"DELETE FROM flip_tg.tg_link WHERE hash = ? ";
        let p = Params::Positional(vec![self.hash.clone().into()]);

        conn.exec_drop(
            query, p
        ).await?;

        Ok(())
    }
}


#[derive(Default, Debug)]
pub struct TgLinkSelector {
    wheres: Vec<WhereClause>,
    select_cols: Vec<&'static str>,
    order_by:  Vec<&'static str>,
    limit: u32,
    offset: u32,
}

impl TgLinkSelector {
    pub fn new() -> Self {
        TgLinkSelector::default()
    }

    pub fn limit(&mut self, size: u32) -> &mut Self {
        self.limit = size;
        self
    }

    pub fn offset(&mut self, size: u32) -> &mut Self {
        self.offset = size;
        self
    }

    pub fn select_all(&mut self) -> &mut Self {
        // Default is select *
        self
    }

    //each column select
    pub fn select_hash(&mut self) -> &mut Self {
        self.select_cols.push("hash");
        self
    }
    
    pub fn select_channel_id(&mut self) -> &mut Self {
        self.select_cols.push("channel_id");
        self
    }
    
    pub fn select_expired(&mut self) -> &mut Self {
        self.select_cols.push("expired");
        self
    }
    

    fn _to_cql(&self) ->  (String, Vec<Value>)  {
        let cql_select = if self.select_cols.is_empty() {
            "*".to_string()
        } else {
            self.select_cols.join(", ")
        };

        let mut cql_query = format!("SELECT {} FROM flip_tg.tg_link", cql_select);

        let (cql_where, where_values) = _get_where(self.wheres.clone());

        if where_values.len() > 0 {
            cql_query.push_str(&format!(" WHERE {}",&cql_where));
        }

        if self.order_by.len() > 0 {
            let cql_orders = self.order_by.join(", ");
            cql_query.push_str( &format!(" ORDER BY {}", &cql_orders));
        };

        if self.limit != 0  {
            cql_query.push_str(&format!(" LIMIT {} ", self.limit));
        };

        if self.offset != 0  {
            cql_query.push_str(&format!(" OFFSET {} ", self.offset));
        };

        (cql_query, where_values)
    }

    pub async fn _get_rows_with_size(&mut self, session: &Pool, size: i64) -> Result<Vec<TgLink>, MyError>   {
        let mut conn = session.get_conn().await?;
        let(cql_query, query_values) = self._to_cql();

        println!("{} - {:?}", &cql_query, &query_values);

        let p = Params::Positional(query_values);

        let query_result = conn
            .exec_map(
                cql_query,p,
                |obj: TgLink| obj
            ).await?;

        Ok(query_result)
    }

    pub async fn get_rows(&mut self, session: &Pool) -> Result<Vec<TgLink>, MyError>{
        self._get_rows_with_size(session,-1).await
    }

    pub async fn get_row(&mut self, session: &Pool) -> Result<TgLink, MyError>{
        let rows = self._get_rows_with_size(session,1).await?;

        let opt = rows.get(0);
        match opt {
            Some(row) => Ok(row.to_owned()),
            None => Err(MyError::NotFound)
        }
    }

    // Modifiers

    
    pub fn order_by_hash_asc(&mut self) -> &mut Self {
		self.order_by.push("hash ASC");
        self
    }

	pub fn order_by_hash_desc(&mut self) -> &mut Self {
		self.order_by.push("hash DESC");
        self
    }

    pub fn order_by_channel_id_asc(&mut self) -> &mut Self {
		self.order_by.push("channel_id ASC");
        self
    }

	pub fn order_by_channel_id_desc(&mut self) -> &mut Self {
		self.order_by.push("channel_id DESC");
        self
    }

    pub fn order_by_expired_asc(&mut self) -> &mut Self {
		self.order_by.push("expired ASC");
        self
    }

	pub fn order_by_expired_desc(&mut self) -> &mut Self {
		self.order_by.push("expired DESC");
        self
    }


    
    pub fn hash_eq (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: " hash = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn hash_lt (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: " hash < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn hash_le (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: " hash <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn hash_gt (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: " hash > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn hash_ge (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: " hash >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_hash_eq (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: "AND hash = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_hash_lt (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: "AND hash < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_hash_le (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: "AND hash <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_hash_gt (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: "AND hash > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_hash_ge (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: "AND hash >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_hash_eq (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: "OR hash = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_hash_lt (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: "OR hash < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_hash_le (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: "OR hash <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_hash_gt (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: "OR hash > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_hash_ge (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: "OR hash >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn channel_id_eq (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " channel_id = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn channel_id_lt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " channel_id < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn channel_id_le (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " channel_id <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn channel_id_gt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " channel_id > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn channel_id_ge (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " channel_id >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_channel_id_eq (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND channel_id = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_channel_id_lt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND channel_id < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_channel_id_le (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND channel_id <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_channel_id_gt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND channel_id > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_channel_id_ge (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND channel_id >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_channel_id_eq (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR channel_id = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_channel_id_lt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR channel_id < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_channel_id_le (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR channel_id <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_channel_id_gt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR channel_id > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_channel_id_ge (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR channel_id >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn expired_eq (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " expired = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn expired_lt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " expired < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn expired_le (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " expired <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn expired_gt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " expired > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn expired_ge (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " expired >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_expired_eq (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND expired = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_expired_lt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND expired < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_expired_le (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND expired <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_expired_gt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND expired > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_expired_ge (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND expired >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_expired_eq (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR expired = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_expired_lt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR expired < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_expired_le (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR expired <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_expired_gt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR expired > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_expired_ge (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR expired >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }


    //{* .GetRustWhereInsTmplOut *}

}


#[derive(Debug, PartialEq, Eq, Clone)]
pub struct TgUsername  { // tg_username
    pub username: String,
    pub channel_id: u32,
    pub user_id: u32,
    pub not_occupied: u32,
}

impl FromRow for TgUsername {
    fn from_row_opt(row: Row) -> Result<Self, FromRowError>
    where
        Self: Sized,
    {
        Ok(TgUsername  {
            username: row.get(0).unwrap_or_default(),
            channel_id: row.get(1).unwrap_or_default(),
            user_id: row.get(2).unwrap_or_default(),
            not_occupied: row.get(3).unwrap_or_default(),
        })
    }
}

impl TgUsername {
    pub async fn insert(&self, pool: &Pool) -> Result<TgUsername,MyError> {
        let mut conn = pool.get_conn().await?;

        let query = r"INSERT INTO flip_tg.tg_username (username, channel_id, user_id, not_occupied) VALUES (?, ?, ?, ?)";
        let p = Params::Positional(vec![self.username.clone().into(), self.channel_id.clone().into(), self.user_id.clone().into(), self.not_occupied.clone().into()]);

        conn.exec_iter(
            query, p
        ).await?;

        let cp = self.clone();

       Ok(cp)
    }

    pub async fn update(&self, pool: &Pool) -> Result<(),MyError> {
        let mut conn = pool.get_conn().await?;
        let query = r"UPDATE flip_tg.tg_username SET channel_id = ?, user_id = ?, not_occupied = ? WHERE username = ? ";
        let p = Params::Positional(vec![self.channel_id.clone().into(), self.user_id.clone().into(), self.not_occupied.clone().into(),  self.username.clone().into() ]);

        let qr = conn.exec_iter(
            query, p
        ).await?;

        Ok(())
    }

    pub async fn delete(&self, pool: &Pool) -> Result<(),MyError> {
        let mut conn = pool.get_conn().await?;

        let query = r"DELETE FROM flip_tg.tg_username WHERE username = ? ";
        let p = Params::Positional(vec![self.username.clone().into()]);

        conn.exec_drop(
            query, p
        ).await?;

        Ok(())
    }
}


#[derive(Default, Debug)]
pub struct TgUsernameSelector {
    wheres: Vec<WhereClause>,
    select_cols: Vec<&'static str>,
    order_by:  Vec<&'static str>,
    limit: u32,
    offset: u32,
}

impl TgUsernameSelector {
    pub fn new() -> Self {
        TgUsernameSelector::default()
    }

    pub fn limit(&mut self, size: u32) -> &mut Self {
        self.limit = size;
        self
    }

    pub fn offset(&mut self, size: u32) -> &mut Self {
        self.offset = size;
        self
    }

    pub fn select_all(&mut self) -> &mut Self {
        // Default is select *
        self
    }

    //each column select
    pub fn select_username(&mut self) -> &mut Self {
        self.select_cols.push("username");
        self
    }
    
    pub fn select_channel_id(&mut self) -> &mut Self {
        self.select_cols.push("channel_id");
        self
    }
    
    pub fn select_user_id(&mut self) -> &mut Self {
        self.select_cols.push("user_id");
        self
    }
    
    pub fn select_not_occupied(&mut self) -> &mut Self {
        self.select_cols.push("not_occupied");
        self
    }
    

    fn _to_cql(&self) ->  (String, Vec<Value>)  {
        let cql_select = if self.select_cols.is_empty() {
            "*".to_string()
        } else {
            self.select_cols.join(", ")
        };

        let mut cql_query = format!("SELECT {} FROM flip_tg.tg_username", cql_select);

        let (cql_where, where_values) = _get_where(self.wheres.clone());

        if where_values.len() > 0 {
            cql_query.push_str(&format!(" WHERE {}",&cql_where));
        }

        if self.order_by.len() > 0 {
            let cql_orders = self.order_by.join(", ");
            cql_query.push_str( &format!(" ORDER BY {}", &cql_orders));
        };

        if self.limit != 0  {
            cql_query.push_str(&format!(" LIMIT {} ", self.limit));
        };

        if self.offset != 0  {
            cql_query.push_str(&format!(" OFFSET {} ", self.offset));
        };

        (cql_query, where_values)
    }

    pub async fn _get_rows_with_size(&mut self, session: &Pool, size: i64) -> Result<Vec<TgUsername>, MyError>   {
        let mut conn = session.get_conn().await?;
        let(cql_query, query_values) = self._to_cql();

        println!("{} - {:?}", &cql_query, &query_values);

        let p = Params::Positional(query_values);

        let query_result = conn
            .exec_map(
                cql_query,p,
                |obj: TgUsername| obj
            ).await?;

        Ok(query_result)
    }

    pub async fn get_rows(&mut self, session: &Pool) -> Result<Vec<TgUsername>, MyError>{
        self._get_rows_with_size(session,-1).await
    }

    pub async fn get_row(&mut self, session: &Pool) -> Result<TgUsername, MyError>{
        let rows = self._get_rows_with_size(session,1).await?;

        let opt = rows.get(0);
        match opt {
            Some(row) => Ok(row.to_owned()),
            None => Err(MyError::NotFound)
        }
    }

    // Modifiers

    
    pub fn order_by_username_asc(&mut self) -> &mut Self {
		self.order_by.push("username ASC");
        self
    }

	pub fn order_by_username_desc(&mut self) -> &mut Self {
		self.order_by.push("username DESC");
        self
    }

    pub fn order_by_channel_id_asc(&mut self) -> &mut Self {
		self.order_by.push("channel_id ASC");
        self
    }

	pub fn order_by_channel_id_desc(&mut self) -> &mut Self {
		self.order_by.push("channel_id DESC");
        self
    }

    pub fn order_by_user_id_asc(&mut self) -> &mut Self {
		self.order_by.push("user_id ASC");
        self
    }

	pub fn order_by_user_id_desc(&mut self) -> &mut Self {
		self.order_by.push("user_id DESC");
        self
    }

    pub fn order_by_not_occupied_asc(&mut self) -> &mut Self {
		self.order_by.push("not_occupied ASC");
        self
    }

	pub fn order_by_not_occupied_desc(&mut self) -> &mut Self {
		self.order_by.push("not_occupied DESC");
        self
    }


    
    pub fn username_eq (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: " username = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn username_lt (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: " username < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn username_le (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: " username <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn username_gt (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: " username > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn username_ge (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: " username >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_username_eq (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: "AND username = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_username_lt (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: "AND username < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_username_le (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: "AND username <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_username_gt (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: "AND username > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_username_ge (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: "AND username >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_username_eq (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: "OR username = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_username_lt (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: "OR username < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_username_le (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: "OR username <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_username_gt (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: "OR username > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_username_ge (&mut self, val: &str ) -> &mut Self {
        let w = WhereClause{
            condition: "OR username >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn channel_id_eq (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " channel_id = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn channel_id_lt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " channel_id < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn channel_id_le (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " channel_id <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn channel_id_gt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " channel_id > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn channel_id_ge (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " channel_id >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_channel_id_eq (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND channel_id = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_channel_id_lt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND channel_id < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_channel_id_le (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND channel_id <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_channel_id_gt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND channel_id > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_channel_id_ge (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND channel_id >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_channel_id_eq (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR channel_id = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_channel_id_lt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR channel_id < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_channel_id_le (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR channel_id <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_channel_id_gt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR channel_id > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_channel_id_ge (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR channel_id >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn user_id_eq (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " user_id = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn user_id_lt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " user_id < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn user_id_le (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " user_id <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn user_id_gt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " user_id > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn user_id_ge (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " user_id >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_user_id_eq (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND user_id = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_user_id_lt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND user_id < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_user_id_le (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND user_id <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_user_id_gt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND user_id > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_user_id_ge (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND user_id >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_user_id_eq (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR user_id = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_user_id_lt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR user_id < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_user_id_le (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR user_id <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_user_id_gt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR user_id > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_user_id_ge (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR user_id >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn not_occupied_eq (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " not_occupied = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn not_occupied_lt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " not_occupied < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn not_occupied_le (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " not_occupied <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn not_occupied_gt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " not_occupied > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn not_occupied_ge (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: " not_occupied >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_not_occupied_eq (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND not_occupied = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_not_occupied_lt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND not_occupied < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_not_occupied_le (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND not_occupied <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_not_occupied_gt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND not_occupied > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn and_not_occupied_ge (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "AND not_occupied >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_not_occupied_eq (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR not_occupied = ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_not_occupied_lt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR not_occupied < ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_not_occupied_le (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR not_occupied <= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_not_occupied_gt (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR not_occupied > ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }

    pub fn or_not_occupied_ge (&mut self, val: u32 ) -> &mut Self {
        let w = WhereClause{
            condition: "OR not_occupied >= ?".to_string(),
            args: val.into(),
        };
        self.wheres.push(w);
        self
    }


    //{* .GetRustWhereInsTmplOut *}

}



///////////////// SHARED CODE ///////////
#[derive(Debug, Clone)]
pub struct WhereClause {
    // pub condition: &'static str,
    pub condition: String,
    pub args: Value,
}

fn _get_where(wheres: Vec<WhereClause>) ->  (String, Vec<Value>) {
    let mut values = vec![];
    let  mut where_str = vec![];

    for w in wheres {
        where_str.push(w.condition);
        values.push(w.args)
    }
    let cql_where = where_str.join(" ");

    (cql_where, values)
}

#[derive(Debug)]
pub enum MyError { // MySQL Error
    NotFound,
    MySqlError(mysql_async::Error),
}

impl From<mysql_async::Error> for MyError{
    fn from(err: mysql_async::Error) -> Self {
        MyError::MySqlError(err)
    }
}

